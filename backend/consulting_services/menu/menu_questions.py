"""
Menu Engineering Question Handler
Routes and answers 20 specific menu engineering questions for Product Mix, Pricing, and Design.
"""

import os
from typing import Dict, Any, List, Optional
from backend.shared.utils.common import success_payload, error_payload
from backend.consulting_services.kpi.kpi_utils import format_business_report
from .analysis_functions import (
    load_restaurant_data,
    validate_data_integrity,
    join_menu_data,
    calculate_menu_engineering_matrix,
    calculate_product_mix_analysis,
    calculate_menu_pricing_strategy,
    calculate_menu_design_recommendations
)


# ==================== QUESTION ROUTING ====================

QUESTION_PATTERNS = {
    # Product Mix Analysis (8 questions)
    "highest_contribution_margin": ["highest contribution margin", "best margin", "most profitable items"],
    "top_profit_percentage": ["top 5", "top selling", "profit percentage", "pareto"],
    "dog_quadrant": ["dog quadrant", "remove items", "low popularity low profit", "underperformers"],
    "sales_trends_category": ["sales trends", "month over month", "category trends", "trend analysis"],
    "menu_mix_percentages": ["menu mix", "category percentage", "mix percentages", "industry benchmark"],
    "hidden_stars": ["hidden stars", "high margin low sales", "strong margins low velocity"],
    "profit_per_labor_minute": ["profit per labor", "labor minute", "efficiency by category"],
    "average_check_influence": ["average check", "check size", "product mix influence"],

    # Menu Pricing (7 questions)
    "undervalued_items": ["undervalued", "underpriced", "perceived value", "cost percentage"],
    "price_increase_impact": ["price increase", "increase by", "profit gained", "what if"],
    "price_elasticity": ["price elasticity", "sales don't drop", "ideal price range"],
    "food_cost_vs_target": ["food cost percentage", "target margin", "compare to target"],
    "pricing_strategy": ["pricing strategy", "cost-plus", "competitive parity", "value-based"],
    "bundling_opportunities": ["bundling", "re-priced", "ticket size", "combo"],
    "vendor_inflation_impact": ["inflation", "vendor price", "sysco", "cost changes"],

    # Menu Design (5 questions)
    "visual_zone_performance": ["visual zones", "upper-right", "prime position", "menu positioning"],
    "callout_effectiveness": ["callouts", "icons", "chef recommendation", "selection rate"],
    "category_sequencing": ["category sequencing", "sequencing", "order effect"],
    "design_value_perception": ["design elements", "perceived value", "price sensitivity", "visual impact"],
    "limited_time_offers": ["limited time", "chef features", "LTO", "short-term sales"]
}


def detect_question_type(user_question: str) -> Optional[str]:
    """
    Detect which of the 20 questions the user is asking.

    Args:
        user_question: The user's question text (lowercase)

    Returns:
        Question type key or None if no match
    """
    user_lower = user_question.lower()

    for question_type, patterns in QUESTION_PATTERNS.items():
        for pattern in patterns:
            if pattern.lower() in user_lower:
                return question_type

    return None


# ==================== PRODUCT MIX QUESTIONS ====================

def answer_highest_contribution_margin(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q1: Which menu items have the highest contribution margin versus their sales volume?
    """
    # Calculate contribution margin for each item
    items_with_margin = []
    for item in unified_data:
        margin = item.get('contribution_margin', 0)
        units_sold = item.get('units_sold', 0)
        items_with_margin.append({
            'name': item.get('menu_name'),
            'contribution_margin': margin,
            'units_sold': units_sold,
            'total_profit': item.get('total_profit', 0),
            'quadrant': item.get('quadrant', 'Unknown')
        })

    # Sort by contribution margin
    sorted_by_margin = sorted(items_with_margin, key=lambda x: x['contribution_margin'], reverse=True)

    return {
        "question": "Which menu items have the highest contribution margin versus their sales volume?",
        "top_10_by_margin": sorted_by_margin[:10],
        "insight": f"Top item: {sorted_by_margin[0]['name']} with {sorted_by_margin[0]['contribution_margin']:.1f}% margin and {sorted_by_margin[0]['units_sold']} units sold.",
        "recommendation": "Focus on promoting high-margin items with strong sales velocity (Stars quadrant)."
    }


def answer_top_profit_percentage(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q2: What percentage of total profit is generated by the top 5 selling items?
    """
    # Sort by units sold
    sorted_by_sales = sorted(unified_data, key=lambda x: x.get('units_sold', 0), reverse=True)

    total_profit = sum(item.get('total_profit', 0) for item in unified_data)
    top_5_profit = sum(item.get('total_profit', 0) for item in sorted_by_sales[:5])

    top_5_percentage = (top_5_profit / total_profit * 100) if total_profit > 0 else 0

    top_5_items = [{
        'name': item.get('menu_name'),
        'units_sold': item.get('units_sold'),
        'total_profit': item.get('total_profit'),
        'profit_percentage': (item.get('total_profit', 0) / total_profit * 100) if total_profit > 0 else 0
    } for item in sorted_by_sales[:5]]

    return {
        "question": "What percentage of total profit is generated by the top 5 selling items?",
        "top_5_profit_percentage": round(top_5_percentage, 1),
        "total_profit": total_profit,
        "top_5_profit": top_5_profit,
        "top_5_items": top_5_items,
        "insight": f"Your top 5 selling items generate {top_5_percentage:.1f}% of total profit (Pareto principle: {'YES' if top_5_percentage >= 80 else 'NO'}).",
        "recommendation": "Protect and promote these top performers" if top_5_percentage >= 60 else "Diversify profit sources to reduce dependency on few items."
    }


def answer_dog_quadrant(analysis_result: Dict) -> Dict[str, Any]:
    """
    Q3: Which items fall into the "Dog" quadrant and should be removed or re-engineered?
    """
    quadrant_data = analysis_result.get('quadrant_breakdown', {})
    dogs = quadrant_data.get('dogs', [])

    dog_items = [{
        'name': item.get('menu_name'),
        'popularity_index': item.get('popularity_index'),
        'profitability_index': item.get('profitability_index'),
        'units_sold': item.get('units_sold'),
        'contribution_margin': item.get('contribution_margin'),
        'recommendation': 'REMOVE' if item.get('contribution_margin', 0) < 60 else 'RE-ENGINEER'
    } for item in dogs]

    return {
        "question": "Which items fall into the Dog quadrant (low popularity, low profit)?",
        "dog_count": len(dogs),
        "dog_items": dog_items,
        "remove_candidates": [item for item in dog_items if item['recommendation'] == 'REMOVE'],
        "reengineer_candidates": [item for item in dog_items if item['recommendation'] == 'RE-ENGINEER'],
        "insight": f"You have {len(dogs)} Dog items. Industry best practice: Dogs should be <15% of menu.",
        "recommendation": "Remove items with <60% margin, re-engineer others by reducing costs or repositioning."
    }


def answer_sales_trends_category(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q4: How have sales trends by category changed month over month?
    Note: This requires historical data. For now, we'll provide current category breakdown.
    """
    # Group by category
    category_sales = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        if category not in category_sales:
            category_sales[category] = {
                'total_units': 0,
                'total_revenue': 0,
                'item_count': 0
            }
        category_sales[category]['total_units'] += item.get('units_sold', 0)
        category_sales[category]['total_revenue'] += item.get('total_revenue', 0)
        category_sales[category]['item_count'] += 1

    return {
        "question": "How have sales trends by category changed month over month?",
        "note": "Historical data not available - showing current category breakdown",
        "category_breakdown": category_sales,
        "insight": f"Analyzed {len(category_sales)} categories across {len(unified_data)} items.",
        "recommendation": "Track monthly sales data to identify trends. Consider seasonal adjustments."
    }


def answer_menu_mix_percentages(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q5: What are the menu mix percentages by category and how do they compare to industry benchmarks?
    """
    # Calculate category mix percentages
    total_units = sum(item.get('units_sold', 0) for item in unified_data)

    category_mix = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        if category not in category_mix:
            category_mix[category] = {'units': 0, 'revenue': 0}
        category_mix[category]['units'] += item.get('units_sold', 0)
        category_mix[category]['revenue'] += item.get('total_revenue', 0)

    # Calculate percentages and compare to benchmarks
    industry_benchmarks = {
        'Appetizers': {'min': 15, 'max': 25, 'optimal': 20},
        'Entrees': {'min': 40, 'max': 50, 'optimal': 45},
        'Desserts': {'min': 10, 'max': 15, 'optimal': 12},
        'Beverages': {'min': 15, 'max': 25, 'optimal': 20}
    }

    mix_analysis = {}
    for category, data in category_mix.items():
        percentage = (data['units'] / total_units * 100) if total_units > 0 else 0
        benchmark = industry_benchmarks.get(category, {'optimal': 25})

        mix_analysis[category] = {
            'percentage': round(percentage, 1),
            'units': data['units'],
            'revenue': data['revenue'],
            'benchmark': benchmark.get('optimal'),
            'status': 'OPTIMAL' if abs(percentage - benchmark.get('optimal', percentage)) < 5 else 'ADJUST'
        }

    return {
        "question": "What are the menu mix percentages by category?",
        "menu_mix": mix_analysis,
        "insight": f"Categories analyzed: {len(mix_analysis)}",
        "recommendation": "Adjust mix to match industry benchmarks for optimal revenue."
    }


def answer_hidden_stars(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q6: Which items have strong margins but low sales velocity (possible hidden stars)?
    """
    # Find items with high margin (>70%) but low sales
    median_sales = sorted([item.get('units_sold', 0) for item in unified_data])[len(unified_data) // 2]

    hidden_stars = []
    for item in unified_data:
        margin = item.get('contribution_margin', 0)
        units = item.get('units_sold', 0)

        if margin > 70 and units < median_sales:
            hidden_stars.append({
                'name': item.get('menu_name'),
                'contribution_margin': margin,
                'units_sold': units,
                'category': item.get('category'),
                'quadrant': item.get('quadrant'),
                'potential': 'HIGH' if margin > 75 else 'MEDIUM'
            })

    hidden_stars.sort(key=lambda x: x['contribution_margin'], reverse=True)

    return {
        "question": "Which items have strong margins but low sales velocity?",
        "hidden_stars_count": len(hidden_stars),
        "hidden_stars": hidden_stars[:10],
        "median_sales": median_sales,
        "insight": f"Found {len(hidden_stars)} high-margin items with sales below median.",
        "recommendation": "Increase visibility through menu placement, server upselling, or promotional campaigns."
    }


def answer_profit_per_labor_minute(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q7: How does the profit per labor minute compare across menu categories?
    Note: Requires labor time data per item. Using estimated prep complexity.
    """
    # Estimate labor complexity (simple heuristic)
    category_labor_estimates = {
        'Appetizers': 5,    # minutes
        'Salads': 3,
        'Soups': 8,
        'Entrees': 15,
        'Steaks': 20,
        'Seafood': 18,
        'Pasta': 12,
        'Sandwiches': 5,
        'Desserts': 8,
        'Beverages': 2
    }

    category_analysis = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        labor_time = category_labor_estimates.get(category, 10)

        if category not in category_analysis:
            category_analysis[category] = {
                'total_profit': 0,
                'total_labor_minutes': 0,
                'item_count': 0
            }

        units = item.get('units_sold', 0)
        profit_per_unit = item.get('contribution_margin_dollars', 0)

        category_analysis[category]['total_profit'] += profit_per_unit * units
        category_analysis[category]['total_labor_minutes'] += labor_time * units
        category_analysis[category]['item_count'] += 1

    # Calculate profit per labor minute
    for category, data in category_analysis.items():
        if data['total_labor_minutes'] > 0:
            data['profit_per_labor_minute'] = data['total_profit'] / data['total_labor_minutes']
        else:
            data['profit_per_labor_minute'] = 0

    # Sort by efficiency
    sorted_categories = sorted(
        category_analysis.items(),
        key=lambda x: x[1]['profit_per_labor_minute'],
        reverse=True
    )

    return {
        "question": "How does profit per labor minute compare across categories?",
        "note": "Labor times are estimated based on category complexity",
        "category_analysis": {cat: data for cat, data in sorted_categories},
        "most_efficient": sorted_categories[0][0] if sorted_categories else None,
        "least_efficient": sorted_categories[-1][0] if sorted_categories else None,
        "insight": f"Most efficient: {sorted_categories[0][0]} at ${sorted_categories[0][1]['profit_per_labor_minute']:.2f}/min",
        "recommendation": "Focus kitchen capacity on high-profit-per-minute items during peak hours."
    }


def answer_average_check_influence(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q8: What is the average check size and how does product mix influence it?
    """
    total_revenue = sum(item.get('total_revenue', 0) for item in unified_data)
    total_units = sum(item.get('units_sold', 0) for item in unified_data)

    avg_check = total_revenue / total_units if total_units > 0 else 0

    # Analyze by category
    category_contribution = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        if category not in category_contribution:
            category_contribution[category] = {
                'revenue': 0,
                'units': 0,
                'avg_price': 0
            }
        category_contribution[category]['revenue'] += item.get('total_revenue', 0)
        category_contribution[category]['units'] += item.get('units_sold', 0)

    for category, data in category_contribution.items():
        data['avg_price'] = data['revenue'] / data['units'] if data['units'] > 0 else 0
        data['contribution_to_check'] = (data['revenue'] / total_revenue * 100) if total_revenue > 0 else 0

    return {
        "question": "What is the average check size and how does product mix influence it?",
        "average_check": round(avg_check, 2),
        "total_revenue": total_revenue,
        "total_transactions": total_units,
        "category_contribution": category_contribution,
        "insight": f"Average check: ${avg_check:.2f}. Highest contributor: {max(category_contribution.items(), key=lambda x: x[1]['contribution_to_check'])[0]}",
        "recommendation": "Increase check size by upselling high-margin add-ons and premium items."
    }


# ==================== MENU PRICING QUESTIONS ====================

def answer_undervalued_items(pricing_analysis: Dict) -> Dict[str, Any]:
    """
    Q9: Which menu items are undervalued based on cost percentage and perceived value?
    """
    underpriced = pricing_analysis.get('underpriced_items', [])

    undervalued = [{
        'name': item.get('menu_name'),
        'current_price': item.get('current_price'),
        'optimal_price': item.get('optimal_price'),
        'price_gap': item.get('price_gap'),
        'food_cost_percent': item.get('food_cost_percent'),
        'potential_revenue': item.get('potential_additional_revenue')
    } for item in underpriced]

    total_potential = sum(item.get('potential_revenue', 0) for item in undervalued)

    return {
        "question": "Which menu items are undervalued?",
        "undervalued_count": len(undervalued),
        "undervalued_items": undervalued[:10],
        "total_potential_revenue": total_potential,
        "insight": f"Found {len(undervalued)} underpriced items with ${total_potential:,.2f} revenue potential.",
        "recommendation": "Gradually increase prices on undervalued items to optimal levels."
    }


def answer_price_increase_impact(unified_data: List[Dict], increase_amount: float = 0.50) -> Dict[str, Any]:
    """
    Q10: How much profit would be gained if each item's price increased by $0.50 or 1%?
    """
    total_current_profit = sum(item.get('total_profit', 0) for item in unified_data)
    total_units = sum(item.get('units_sold', 0) for item in unified_data)

    # Scenario 1: $0.50 increase
    flat_increase_profit = total_units * increase_amount

    # Scenario 2: 1% increase
    percent_increase_profit = total_current_profit * 0.01

    # Item-by-item analysis
    item_impacts = []
    for item in unified_data:
        units = item.get('units_sold', 0)
        current_price = item.get('price', 0)

        flat_impact = units * increase_amount
        percent_impact = units * (current_price * 0.01)

        item_impacts.append({
            'name': item.get('menu_name'),
            'units_sold': units,
            'flat_increase_profit': flat_impact,
            'percent_increase_profit': percent_impact,
            'better_strategy': 'FLAT' if flat_impact > percent_impact else 'PERCENT'
        })

    item_impacts.sort(key=lambda x: x['flat_increase_profit'], reverse=True)

    return {
        "question": f"How much profit from ${increase_amount:.2f} or 1% price increase?",
        "flat_increase_profit": round(flat_increase_profit, 2),
        "percent_increase_profit": round(percent_increase_profit, 2),
        "better_strategy": "FLAT $0.50" if flat_increase_profit > percent_increase_profit else "PERCENT 1%",
        "top_10_impact_items": item_impacts[:10],
        "insight": f"${increase_amount:.2f} flat increase = ${flat_increase_profit:,.2f}, 1% increase = ${percent_increase_profit:,.2f}",
        "recommendation": "Test price increases on high-volume items first."
    }


def answer_price_elasticity(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q11: What is the ideal price elasticity range for each item?
    Note: Requires historical price/sales data. Providing estimates based on category.
    """
    # Elasticity estimates by category (industry standards)
    elasticity_by_category = {
        'Appetizers': {'elasticity': -0.8, 'description': 'Somewhat elastic'},
        'Entrees': {'elasticity': -1.2, 'description': 'Elastic'},
        'Desserts': {'elasticity': -0.5, 'description': 'Inelastic'},
        'Beverages': {'elasticity': -0.3, 'description': 'Very inelastic'},
        'Steaks': {'elasticity': -1.5, 'description': 'Highly elastic'},
        'Seafood': {'elasticity': -1.3, 'description': 'Elastic'}
    }

    item_elasticity = []
    for item in unified_data:
        category = item.get('category', 'Unknown')
        elasticity_data = elasticity_by_category.get(category, {'elasticity': -1.0, 'description': 'Normal'})

        # Calculate safe price increase range
        current_price = item.get('price', 0)
        elasticity = elasticity_data['elasticity']

        # Rule: Can increase price without losing sales if elasticity > -1
        safe_increase_pct = min(10, abs(100 / elasticity)) if elasticity != 0 else 5

        item_elasticity.append({
            'name': item.get('menu_name'),
            'category': category,
            'current_price': current_price,
            'elasticity': elasticity,
            'description': elasticity_data['description'],
            'safe_price_increase_pct': round(safe_increase_pct, 1),
            'recommended_new_price': round(current_price * (1 + safe_increase_pct/100), 2)
        })

    return {
        "question": "What is the ideal price elasticity range for each item?",
        "note": "Elasticity estimates based on industry category standards",
        "item_elasticity": item_elasticity[:15],
        "insight": "Items with elasticity > -1.0 can handle price increases better",
        "recommendation": "Focus price increases on inelastic items (desserts, beverages)."
    }


def answer_food_cost_vs_target(unified_data: List[Dict], target_food_cost: float = 30.0) -> Dict[str, Any]:
    """
    Q12: How do food cost percentages by item compare to target margins?
    """
    items_vs_target = []
    above_target_count = 0
    on_target_count = 0

    for item in unified_data:
        food_cost_pct = item.get('food_cost_percent', 0)
        variance = food_cost_pct - target_food_cost

        if food_cost_pct > target_food_cost + 2:
            status = 'ABOVE TARGET'
            above_target_count += 1
        elif food_cost_pct < target_food_cost - 2:
            status = 'BELOW TARGET'
        else:
            status = 'ON TARGET'
            on_target_count += 1

        items_vs_target.append({
            'name': item.get('menu_name'),
            'food_cost_percent': food_cost_pct,
            'target': target_food_cost,
            'variance': round(variance, 1),
            'status': status
        })

    # Sort by variance (worst first)
    items_vs_target.sort(key=lambda x: x['variance'], reverse=True)

    return {
        "question": f"How do food costs compare to {target_food_cost}% target?",
        "target_food_cost": target_food_cost,
        "above_target_count": above_target_count,
        "on_target_count": on_target_count,
        "items_analysis": items_vs_target[:15],
        "worst_offenders": items_vs_target[:5],
        "insight": f"{above_target_count} items above target, {on_target_count} on target",
        "recommendation": "Review recipes and portion sizes for items >2% above target."
    }


def answer_pricing_strategy(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q13: What pricing strategy yields the best results?
    """
    # Analyze current pricing approach
    strategy_analysis = {
        'cost_plus': {'count': 0, 'avg_margin': 0, 'total_revenue': 0},
        'competitive': {'count': 0, 'avg_margin': 0, 'total_revenue': 0},
        'value_based': {'count': 0, 'avg_margin': 0, 'total_revenue': 0}
    }

    for item in unified_data:
        margin = item.get('contribution_margin', 0)
        revenue = item.get('total_revenue', 0)

        # Classify strategy based on margin
        if margin < 65:
            strategy = 'competitive'  # Lower margin = competitive pricing
        elif margin > 75:
            strategy = 'value_based'   # High margin = value pricing
        else:
            strategy = 'cost_plus'     # Medium margin = cost-plus

        strategy_analysis[strategy]['count'] += 1
        strategy_analysis[strategy]['total_revenue'] += revenue

    # Calculate averages
    total_items = len(unified_data)
    for strategy, data in strategy_analysis.items():
        if data['count'] > 0:
            data['percentage'] = (data['count'] / total_items * 100)
            data['avg_revenue_per_item'] = data['total_revenue'] / data['count']
        else:
            data['percentage'] = 0
            data['avg_revenue_per_item'] = 0

    best_strategy = max(strategy_analysis.items(), key=lambda x: x[1]['avg_revenue_per_item'])

    return {
        "question": "What pricing strategy yields the best results?",
        "strategy_breakdown": strategy_analysis,
        "best_strategy": best_strategy[0],
        "insight": f"{best_strategy[0].upper()} pricing generates ${best_strategy[1]['avg_revenue_per_item']:,.2f} avg revenue/item",
        "recommendation": f"Shift more items to {best_strategy[0]} pricing for optimal results."
    }


def answer_bundling_opportunities(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q14: Are there menu items that could be bundled to increase ticket size?
    """
    # Identify complementary items by category
    categories = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        if category not in categories:
            categories[category] = []
        categories[category].append(item)

    # Suggest bundles
    bundle_opportunities = []

    # Appetizer + Entree bundles
    if 'Appetizers' in categories and 'Entrees' in categories:
        for app in categories['Appetizers'][:3]:
            for entree in categories['Entrees'][:3]:
                bundle_price = app.get('price', 0) + entree.get('price', 0)
                discounted_price = bundle_price * 0.90  # 10% discount

                bundle_opportunities.append({
                    'bundle_name': f"{app.get('menu_name')} + {entree.get('menu_name')}",
                    'items': [app.get('menu_name'), entree.get('menu_name')],
                    'regular_price': round(bundle_price, 2),
                    'bundle_price': round(discounted_price, 2),
                    'savings': round(bundle_price - discounted_price, 2),
                    'estimated_appeal': 'HIGH' if app.get('quadrant') == 'stars' and entree.get('quadrant') == 'stars' else 'MEDIUM'
                })

    # Entree + Dessert bundles
    if 'Entrees' in categories and 'Desserts' in categories:
        for entree in categories['Entrees'][:2]:
            for dessert in categories['Desserts'][:2]:
                bundle_price = entree.get('price', 0) + dessert.get('price', 0)
                discounted_price = bundle_price * 0.92  # 8% discount

                bundle_opportunities.append({
                    'bundle_name': f"{entree.get('menu_name')} + {dessert.get('menu_name')}",
                    'items': [entree.get('menu_name'), dessert.get('menu_name')],
                    'regular_price': round(bundle_price, 2),
                    'bundle_price': round(discounted_price, 2),
                    'savings': round(bundle_price - discounted_price, 2),
                    'estimated_appeal': 'MEDIUM'
                })

    return {
        "question": "What bundling opportunities exist to increase ticket size?",
        "bundle_opportunities": bundle_opportunities[:10],
        "insight": f"Identified {len(bundle_opportunities)} potential bundle combinations",
        "recommendation": "Test top 3 bundles as limited-time offers to gauge customer response."
    }


def answer_vendor_inflation_impact(unified_data: List[Dict], inflation_rate: float = 5.0) -> Dict[str, Any]:
    """
    Q15: What is the impact of inflation on profitability?
    """
    total_revenue = sum(item.get('total_revenue', 0) for item in unified_data)
    total_cost = sum(item.get('total_cost', 0) for item in unified_data)
    current_profit = total_revenue - total_cost

    # Calculate impact of inflation
    inflated_cost = total_cost * (1 + inflation_rate/100)
    new_profit = total_revenue - inflated_cost
    profit_loss = current_profit - new_profit

    # Item-by-item analysis
    item_impacts = []
    for item in unified_data:
        current_cost = item.get('recipe_cost', 0)
        inflated_item_cost = current_cost * (1 + inflation_rate/100)
        cost_increase = inflated_item_cost - current_cost
        units = item.get('units_sold', 0)
        total_impact = cost_increase * units

        # Calculate required price increase to maintain margin
        current_price = item.get('price', 0)
        required_new_price = current_price + cost_increase
        price_increase_pct = (cost_increase / current_price * 100) if current_price > 0 else 0

        item_impacts.append({
            'name': item.get('menu_name'),
            'current_cost': current_cost,
            'inflated_cost': round(inflated_item_cost, 2),
            'cost_increase': round(cost_increase, 2),
            'total_impact': round(total_impact, 2),
            'required_price_increase_pct': round(price_increase_pct, 1),
            'suggested_new_price': round(required_new_price, 2)
        })

    item_impacts.sort(key=lambda x: x['total_impact'], reverse=True)

    return {
        "question": f"What is the impact of {inflation_rate}% vendor inflation?",
        "inflation_rate": inflation_rate,
        "current_profit": round(current_profit, 2),
        "profit_after_inflation": round(new_profit, 2),
        "profit_loss": round(profit_loss, 2),
        "profit_loss_percentage": round((profit_loss / current_profit * 100) if current_profit > 0 else 0, 1),
        "item_impacts": item_impacts[:15],
        "top_5_affected": item_impacts[:5],
        "insight": f"{inflation_rate}% inflation reduces profit by ${profit_loss:,.2f} ({(profit_loss/current_profit*100):.1f}%)",
        "recommendation": "Implement strategic price increases or negotiate with suppliers to offset inflation."
    }


# ==================== MENU DESIGN QUESTIONS ====================

def answer_visual_zone_performance(design_analysis: Dict) -> Dict[str, Any]:
    """
    Q16: Which items are in prime visual zones and how do they perform?
    """
    golden_triangle = design_analysis.get('golden_triangle_placement', [])

    prime_zone_items = []
    for item in golden_triangle[:10]:  # Top 10 prime positions
        prime_zone_items.append({
            'name': item.get('menu_name'),
            'quadrant': item.get('quadrant'),
            'priority': item.get('placement_priority'),
            'units_sold': item.get('units_sold'),
            'total_profit': item.get('total_profit'),
            'recommended_zone': 'Upper-Right (Golden Triangle)' if item.get('quadrant') == 'stars' else 'Secondary Position'
        })

    return {
        "question": "Which items are positioned in prime visual zones?",
        "golden_triangle_items": prime_zone_items,
        "insight": f"Top {len(prime_zone_items)} items recommended for prime positioning",
        "recommendation": "Place Star items in upper-right quadrant where eyes naturally go first."
    }


def answer_callout_effectiveness(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q17: What is the effect of callouts and icons on selection rate?
    Note: Requires A/B test data. Providing recommendations.
    """
    # Identify which items should get callouts
    stars = [item for item in unified_data if item.get('quadrant') == 'stars']
    puzzles = [item for item in unified_data if item.get('quadrant') == 'puzzles']

    callout_recommendations = []

    # Stars should get "Customer Favorite" or "Best Seller"
    for item in stars[:5]:
        callout_recommendations.append({
            'name': item.get('menu_name'),
            'recommended_callout': 'â­ Customer Favorite',
            'reason': 'High popularity & high profit',
            'expected_lift': '15-25% sales increase'
        })

    # Puzzles should get "Chef\'s Special" to boost sales
    for item in puzzles[:3]:
        callout_recommendations.append({
            'name': item.get('menu_name'),
            'recommended_callout': 'ðŸ‘¨â€ðŸ³ Chef\'s Special',
            'reason': 'High profit, needs visibility boost',
            'expected_lift': '10-20% sales increase'
        })

    return {
        "question": "What callouts and icons boost selection rates?",
        "note": "Based on menu engineering principles and industry research",
        "callout_recommendations": callout_recommendations,
        "icon_effectiveness": {
            "â­ Customer Favorite": "15-25% lift",
            "ðŸ‘¨â€ðŸ³ Chef's Special": "10-20% lift",
            "ðŸŒ¶ï¸ Spicy": "5-10% for target audience",
            "ðŸ¥— Healthy Choice": "8-15% for health-conscious",
            "ðŸ“¸ Instagram-Worthy": "12-20% for visual items"
        },
        "insight": f"{len(callout_recommendations)} items recommended for callouts",
        "recommendation": "Use callouts strategically on Stars and Puzzles only - too many reduce effectiveness."
    }


def answer_category_sequencing(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q18: Does category sequencing affect average check or guest spend?
    """
    # Analyze current category distribution
    categories = list(set(item.get('category') for item in unified_data))

    # Recommended sequence based on psychology
    recommended_sequence = [
        {'position': 1, 'category': 'Appetizers', 'reason': 'Prime for high-margin starters'},
        {'position': 2, 'category': 'Salads', 'reason': 'Lighter options before mains'},
        {'position': 3, 'category': 'Entrees', 'reason': 'Peak attention for main dishes'},
        {'position': 4, 'category': 'Steaks/Seafood', 'reason': 'Premium items when appetite is established'},
        {'position': 5, 'category': 'Desserts', 'reason': 'Capitalize on satisfaction for add-ons'},
        {'position': 6, 'category': 'Beverages', 'reason': 'Reinforce throughout meal'}
    ]

    # Calculate average price by category
    category_analysis = {}
    for item in unified_data:
        category = item.get('category', 'Unknown')
        if category not in category_analysis:
            category_analysis[category] = {'total_revenue': 0, 'units': 0, 'avg_price': 0}
        category_analysis[category]['total_revenue'] += item.get('total_revenue', 0)
        category_analysis[category]['units'] += item.get('units_sold', 0)

    for category, data in category_analysis.items():
        data['avg_price'] = data['total_revenue'] / data['units'] if data['units'] > 0 else 0

    return {
        "question": "Does category sequencing affect guest spend?",
        "recommended_sequence": recommended_sequence,
        "current_categories": categories,
        "category_avg_prices": category_analysis,
        "insight": "Sequence impacts check size by 8-15% according to menu psychology research",
        "recommendation": "Place high-margin items (appetizers, desserts) at top and bottom for maximum visibility."
    }


def answer_design_value_perception(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q19: What design elements correlate with perceived value?
    """
    design_recommendations = {
        "typography": {
            "principle": "Omit currency symbols",
            "impact": "12-15% increase in spending",
            "example": "Use '24' instead of '$24.00'"
        },
        "descriptions": {
            "principle": "Detailed item descriptions increase perceived value",
            "impact": "18-25% higher order rate for described items",
            "example": "Instead of 'Salmon', use 'Wild-caught Atlantic salmon, herb-crusted, with lemon beurre blanc'"
        },
        "spacing": {
            "principle": "White space signals premium positioning",
            "impact": "10-12% price sensitivity reduction",
            "example": "Use wider margins for premium items"
        },
        "decoy_pricing": {
            "principle": "High-priced anchor items make others seem reasonable",
            "impact": "20-30% shift to mid-tier items",
            "example": "Include a $45 premium steak to make $32 steaks seem moderate"
        },
        "boxes_highlights": {
            "principle": "Boxes draw attention but reduce perceived value",
            "impact": "Use for high-margin, not premium items",
            "example": "Box appetizers and desserts, not entrees"
        }
    }

    # Identify items for each design treatment
    high_margin_items = [item.get('menu_name') for item in sorted(unified_data, key=lambda x: x.get('contribution_margin', 0), reverse=True)[:5]]
    premium_items = [item.get('menu_name') for item in sorted(unified_data, key=lambda x: x.get('price', 0), reverse=True)[:3]]

    return {
        "question": "What design elements affect perceived value?",
        "design_principles": design_recommendations,
        "high_margin_items_for_boxes": high_margin_items,
        "premium_items_for_descriptions": premium_items,
        "insight": "Design elements can increase perceived value by 15-30% without changing food",
        "recommendation": "Implement all 5 design principles for maximum psychological impact."
    }


def answer_limited_time_offers(unified_data: List[Dict]) -> Dict[str, Any]:
    """
    Q20: How can LTOs and chef features be visually prioritized?
    """
    # Identify best candidates for LTO positioning
    stars = [item for item in unified_data if item.get('quadrant') == 'stars']
    puzzles = [item for item in unified_data if item.get('quadrant') == 'puzzles']

    # LTO strategies
    lto_strategies = [
        {
            "strategy": "Feature Box at Menu Top",
            "target_items": "Star items or new high-margin dishes",
            "expected_lift": "30-40% selection rate",
            "visual_treatment": "Colored box, chef icon, 'Limited Time' badge"
        },
        {
            "strategy": "Chef's Special Insert",
            "target_items": "Seasonal or premium items",
            "expected_lift": "25-35% selection rate",
            "visual_treatment": "Separate insert card, signature font, premium paper"
        },
        {
            "strategy": "Server Recommendation Script",
            "target_items": "High-margin puzzles needing push",
            "expected_lift": "40-50% when verbally recommended",
            "visual_treatment": "Menu notation 'Ask your server'"
        }
    ]

    # Recommend specific items for LTO treatment
    lto_candidates = []

    # Stars that would benefit from LTO boost
    for item in stars[:3]:
        lto_candidates.append({
            'name': item.get('menu_name'),
            'reason': 'Already popular, LTO will maximize revenue',
            'strategy': 'Feature Box',
            'expected_impact': f"${item.get('total_profit', 0) * 1.35:,.2f} profit (+35%)"
        })

    # Puzzles that need visibility
    for item in puzzles[:2]:
        lto_candidates.append({
            'name': item.get('menu_name'),
            'reason': 'High margin but needs awareness',
            'strategy': 'Chef Special + Server Script',
            'expected_impact': f"${item.get('total_profit', 0) * 1.45:,.2f} profit (+45%)"
        })

    return {
        "question": "How can LTOs and chef features be visually prioritized?",
        "lto_strategies": lto_strategies,
        "recommended_lto_items": lto_candidates,
        "insight": f"{len(lto_candidates)} items recommended for LTO treatment",
        "recommendation": "Rotate LTOs weekly, focusing on 2-3 items maximum to create urgency without overwhelming guests."
    }


# ==================== FORMATTING HELPER ====================

def format_answer_as_business_report(question_type: str, answer: Dict[str, Any]) -> str:
    """
    Format question answer as HTML business report using standard format.

    Args:
        question_type: The type of question answered
        answer: Raw answer dictionary

    Returns:
        HTML formatted business report
    """
    question = answer.get('question', 'Menu Engineering Analysis')
    insight = answer.get('insight', '')
    recommendation = answer.get('recommendation', '')
    
    # Build metrics dictionary
    metrics = {}
    recommendations_list = []
    
    # Extract metrics based on answer content
    if 'top_10_by_margin' in answer:
        items = answer['top_10_by_margin']
        if items:
            metrics['Top Item Margin'] = items[0].get('contribution_margin', 0)
            metrics['Top Item Units Sold'] = items[0].get('units_sold', 0)
            metrics['Top Items Count'] = len(items[:10])
    
    if 'top_5_profit_percentage' in answer:
        metrics['Top 5 Profit Percentage'] = answer.get('top_5_profit_percentage', 0)
    
    if 'flat_increase_profit' in answer:
        metrics['Flat Increase Profit'] = answer.get('flat_increase_profit', 0)
        metrics['Percent Increase Profit'] = answer.get('percent_increase_profit', 0)
    
    if 'dog_count' in answer:
        metrics['Dog Items Count'] = answer.get('dog_count', 0)
    
    if 'bundle_opportunities' in answer:
        bundle_count = len(answer.get('bundle_opportunities', []))
        metrics['Bundle Opportunities'] = bundle_count
        if bundle_count > 0:
            metrics['Top Bundles Identified'] = min(bundle_count, 10)
    
    if 'inflation_impact' in answer:
        metrics['Profit Loss'] = answer.get('inflation_impact', {}).get('profit_loss', 0)
        metrics['Cost Increase'] = answer.get('inflation_impact', {}).get('cost_increase', 0)
    
    # Build recommendations list
    if recommendation:
        recommendations_list.append(recommendation)
    
    # Determine performance rating based on metrics
    if 'Dog Items Count' in metrics:
        dog_count = metrics['Dog Items Count']
        if dog_count == 0:
            performance_rating = "Excellent"
        elif dog_count <= 2:
            performance_rating = "Good"
        elif dog_count <= 4:
            performance_rating = "Acceptable"
        else:
            performance_rating = "Needs Improvement"
    elif 'Bundle Opportunities' in metrics:
        bundle_count = metrics['Bundle Opportunities']
        # For bundling, 0 bundles isn't necessarily bad - it's informational
        if bundle_count == 0:
            performance_rating = "Acceptable"  # Informational, not a failure
        elif bundle_count >= 5:
            performance_rating = "Excellent"
        elif bundle_count >= 3:
            performance_rating = "Good"
        else:
            performance_rating = "Acceptable"
    else:
        performance_rating = "Good"
    
    # Build additional insights from answer data
    additional_data = {}
    if insight:
        additional_data['Key Insight'] = insight
    
    # Add data details to additional insights
    if 'top_10_by_margin' in answer and answer['top_10_by_margin']:
        top_items = [item['name'] for item in answer['top_10_by_margin'][:3]]
        additional_data['Top Performers'] = ', '.join(top_items)
    
    if 'bundle_opportunities' in answer and answer['bundle_opportunities']:
        bundles = answer['bundle_opportunities'][:3]
        bundle_names = [f"{b.get('item1', '')} + {b.get('item2', '')}" for b in bundles]
        additional_data['Top Bundle Combinations'] = ', '.join(bundle_names)
    
    # Generate business report using standard format
    business_report = format_business_report(
        analysis_type=question,
        metrics=metrics if metrics else {"Analysis": "Complete"},
        performance={"rating": performance_rating, "color": "blue"},
        recommendations=recommendations_list if recommendations_list else ["Review analysis results for strategic insights."],
        benchmarks=None,
        additional_data=additional_data if additional_data else None
    )
    
    return business_report["business_report_html"]


# ==================== MAIN HANDLER ====================

def run(params: dict, file_bytes: bytes | None = None) -> tuple[dict, int]:
    """
    Main entry point for answering menu engineering questions.

    Args:
        params: Dictionary containing:
            - question (str): The user's question
            - Additional parameters for data loading

    Returns:
        Tuple of (response_dict, status_code)
    """
    service, subtask = "menu", "questions"

    try:
        user_question = params.get("question", "")

        # Detect question type
        question_type = detect_question_type(user_question)

        if not question_type:
            return error_payload(
                service,
                subtask,
                f"Question not recognized. Try asking about product mix, pricing, or design."
            )

        # Load data
        default_data_dir = os.getenv("RESTAURANT_DATA_DIR", "/home/jkatz015/repos/restaurant_inventory_app/data")
        recipe_data_path = params.get("recipe_data_path", os.path.join(default_data_dir, "recipes.json"))
        menu_items_path = params.get("menu_items_path", os.path.join(default_data_dir, "menu_items.json"))
        sales_data_path = params.get("sales_data_path", os.path.join(default_data_dir, "sales_data.json"))

        recipes, menu_items, sales = load_restaurant_data(
            recipe_data_path,
            menu_items_path,
            sales_data_path
        )

        unified_data = join_menu_data(recipes, menu_items, sales, use_precalculated=True)

        # Route to appropriate handler
        answer = None

        # Product Mix questions
        if question_type == "highest_contribution_margin":
            answer = answer_highest_contribution_margin(unified_data)
        elif question_type == "top_profit_percentage":
            answer = answer_top_profit_percentage(unified_data)
        elif question_type == "dog_quadrant":
            analysis = calculate_product_mix_analysis(unified_data)
            answer = answer_dog_quadrant(analysis)
        elif question_type == "sales_trends_category":
            answer = answer_sales_trends_category(unified_data)
        elif question_type == "menu_mix_percentages":
            answer = answer_menu_mix_percentages(unified_data)
        elif question_type == "hidden_stars":
            answer = answer_hidden_stars(unified_data)
        elif question_type == "profit_per_labor_minute":
            answer = answer_profit_per_labor_minute(unified_data)
        elif question_type == "average_check_influence":
            answer = answer_average_check_influence(unified_data)

        # Pricing questions
        elif question_type == "undervalued_items":
            pricing_analysis = calculate_menu_pricing_strategy(unified_data)
            answer = answer_undervalued_items(pricing_analysis)
        elif question_type == "price_increase_impact":
            increase_amount = params.get("increase_amount", 0.50)
            answer = answer_price_increase_impact(unified_data, increase_amount)
        elif question_type == "price_elasticity":
            answer = answer_price_elasticity(unified_data)
        elif question_type == "food_cost_vs_target":
            target = params.get("target_food_cost", 30.0)
            answer = answer_food_cost_vs_target(unified_data, target)
        elif question_type == "pricing_strategy":
            answer = answer_pricing_strategy(unified_data)
        elif question_type == "bundling_opportunities":
            answer = answer_bundling_opportunities(unified_data)
        elif question_type == "vendor_inflation_impact":
            inflation_rate = params.get("inflation_rate", 5.0)
            answer = answer_vendor_inflation_impact(unified_data, inflation_rate)

        # Design questions
        elif question_type == "visual_zone_performance":
            matrix = calculate_menu_engineering_matrix(unified_data)
            design_analysis = calculate_menu_design_recommendations(unified_data, matrix)
            answer = answer_visual_zone_performance(design_analysis)
        elif question_type == "callout_effectiveness":
            answer = answer_callout_effectiveness(unified_data)
        elif question_type == "category_sequencing":
            answer = answer_category_sequencing(unified_data)
        elif question_type == "design_value_perception":
            answer = answer_design_value_perception(unified_data)
        elif question_type == "limited_time_offers":
            answer = answer_limited_time_offers(unified_data)

        if answer:
            # Format as business report with HTML
            formatted_report = format_answer_as_business_report(question_type, answer)

            # Merge formatted report into answer
            answer["business_report_html"] = formatted_report

            return success_payload(service, subtask, params, answer, []), 200
        else:
            return error_payload(service, subtask, "Could not generate answer"), 500

    except Exception as e:
        return error_payload(service, subtask, f"Error processing question: {str(e)}"), 500
